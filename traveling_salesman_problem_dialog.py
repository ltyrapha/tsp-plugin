# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TravelingSalesmanProblemDialog
                                 A QGIS plugin
 to solve TSP
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-07-17
        git sha              : $Format:%H$
        copyright            : (C) 2022 by LTY
        email                : 1643914601@qq.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.QtWidgets import QMessageBox, QFileDialog
from qgis.PyQt import uic, QtWidgets

from qgis.core import *
from qgis.gui import *
from qgis.analysis import *
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.utils import iface

import numpy as np
import time


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'traveling_salesman_problem_dialog_base.ui'))

VERSION_INFO = "QGIS版本：3.16.0-Hannover\nQGIS代码版本：43b64b13f3\nQt版本：5.11.2\nGDAL版本：3.1.4\nGEOS版本：3.8.1-CAPI-1.13.3\nPROJ版本：Rel. 6.3.2, May 1st, 2020"


# tsp问题
class Solution:
    def __init__(self, X, start_node):
        self.X = X  # 距离矩阵
        self.start_node = start_node  # 开始的节点
        self.array = [[0] * (2 ** len(self.X)) for i in range(len(self.X))]  # 记录处于x节点，未经历M个节点时，矩阵储存x的下一步是M中哪个节点

    def transfer(self, sets):
        su = 0
        for s in sets:
            su = su + 2 ** s  # 二进制转换
        return su

    # tsp总接口
    def tsp(self):
        s = self.start_node
        num = len(self.X)
        cities = list(range(num))  # 形成节点的集合
        past_sets = [s]  # 已遍历节点集合
        cities.pop(cities.index(s))  # 构建未经历节点的集合
        node = s  # 初始节点
        return self.solve(node, cities)  # 求解函数

    def solve(self, node, future_sets):
        # 迭代终止条件，表示没有了未遍历节点，直接连接当前节点和起点即可
        if len(future_sets) == 0:
            return self.X[node][self.start_node]
        d = 99999
        # node如果经过future_sets中节点，最后回到原点的距离
        distance = []
        # 遍历未经历的节点
        for i in range(len(future_sets)):
            s_i = future_sets[i]
            copy = future_sets[:]
            copy.pop(i)  # 删除第i个节点，认为已经完成对其的访问
            distance.append(self.X[node][s_i] + self.solve(s_i, copy))
        # 动态规划递推方程，利用递归
        d = min(distance)
        # node需要连接的下一个节点
        next_one = future_sets[distance.index(d)]
        # 未遍历节点集合
        c = self.transfer(future_sets)
        # 回溯矩阵，（当前节点，未遍历节点集合）——>下一个节点
        self.array[node][c] = next_one
        return d


class TravelingSalesmanProblemDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(TravelingSalesmanProblemDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        # 信号和槽连接
        self.pushButtonClose.clicked.connect(self.close)
        self.pushButtonHelp.clicked.connect(self.help)
        self.pushButtonBatch.clicked.connect(self.batch)
        self.pushButtonInputRoad.clicked.connect(self.inputRoad)
        self.pushButtonInputPoint.clicked.connect(self.inputPoint)
        self.pushButtonRun.clicked.connect(self.run)
        self.pushButtonSaveRecord.clicked.connect(self.saveRecord)
        self.pushButtonClearRecord.clicked.connect(self.clearRecord)
        # 一些属性
        self.point = []
        self.cost_arr = np.zeros((6, 6))

    def help(self):
        """帮助说明"""
        QMessageBox(QMessageBox.Information, "Information", "帮助：详情请见右侧算法描述").exec()

    def batch(self):
        """批处理按钮"""
        QMessageBox(QMessageBox.Information, "Information", "批处理部分尚未实现").exec()

    def inputRoad(self):
        """选择一个路网数据文件加载进当前项目中"""
        filename, _ = QFileDialog.getOpenFileName(self, "输入", "", "road files(*.shp *.json)")  # 打开文件选择对话框，仅获取第一个返回的数据（绝对路径）即可
        if filename.strip() == "":
            QMessageBox(QMessageBox.Warning, "警告", "未选择可用路网数据").exec()
            return
        curlayer = QgsVectorLayer(filename, filename.split("/")[-1].split(".")[0], "ogr")  # QgsVectorLayer(data_source, layer_name, provider_name)
        if not curlayer.isValid() or (type(curlayer) != QgsVectorLayer) or (curlayer.geometryType() != 1):  # 如果图层不可获取、不是矢量图层或者类型不是线，则加载失败
            QMessageBox(QMessageBox.Warning, "警告", "图层加载失败：" + filename).exec()
        else:
            QMessageBox(QMessageBox.Information, "信息", "图层加载成功：" + filename).exec()
            self.vectorLayer = curlayer
            self.roadfile = filename
            QgsProject.instance().addMapLayer(curlayer)
            self.comboBoxInputRoad.addItem(curlayer.name())

    def inputPoint(self):
        """选择一个点坐标文件数据"""
        self.point = []
        self.cost_arr = np.zeros((6, 6))
        filename, _ = QFileDialog.getOpenFileName(self, "输入", "", "point files(*.txt *.csv)")  # 打开文件选择对话框，仅获取第一个返回的数据（绝对路径）即可
        if filename.strip() == "":
            QMessageBox(QMessageBox.Warning, "警告", "未选择可用点数据").exec()
            return
        with open(filename, mode="r", encoding="utf-8") as fp:
            for line in fp.readlines():
                oneline = line.strip().split(",")
                print(oneline)
                print(oneline[0])
                print(oneline[1])
                onepoint = [float(oneline[0]), float(oneline[1])]
                self.point.append(onepoint)
        for i in range(0, len(self.point)):
            for j in range(0, i):
                director = QgsVectorLayerDirector(self.vectorLayer, -1, '', '', '', QgsVectorLayerDirector.DirectionBoth)
                strategy = QgsNetworkDistanceStrategy()
                director.addStrategy(strategy)
                builder = QgsGraphBuilder(self.vectorLayer.sourceCrs())
                startPoint = QgsPointXY(self.point[i][0], self.point[i][1])
                endPoint = QgsPointXY(self.point[j][0], self.point[j][1])
                print(startPoint)
                print(endPoint)
                tiedPoints = director.makeGraph(builder, [startPoint, endPoint])
                tStart, tStop = tiedPoints

                graph = builder.graph()
                idxStart = graph.findVertex(tStart)
                idxEnd = graph.findVertex(tStop)
                (tree, costs) = QgsGraphAnalyzer.dijkstra(graph, idxStart, 0)
                if tree[idxEnd] == -1:
                    raise Exception('No route!')
                # Total cost
                cost = costs[idxEnd]
                self.cost_arr[i][j] = cost
                self.cost_arr[j][i] = cost
                del tiedPoints, director, builder, graph, tree, costs
        QMessageBox(QMessageBox.Information, "Infomation", "加载点数据成功").exec()
        self.pointfile = filename
        self.textEditInputPoint.setText(filename)

    def run(self):
        """日志文件"""
        self.progressBarProcess.reset()
        self.progressBarProcess.setRange(0, 3)
        self.progressBarProcess.setValue(1)
        self.textBrowserRecord.append("<font color=\"#FF0000\">" + QDateTime.currentDateTime().toString("[yyyy-MM-dd hh:mm:ss dddd]") + "开始执行</font>")
        self.textBrowserRecord.append("路网线数据:" + self.roadfile)
        self.textBrowserRecord.append("目标点数据:" + self.pointfile)
        """根据输入参数运行"""
        QMessageBox(QMessageBox.Information, "Infomation", "程序现在开始运行").exec()
        S = Solution(self.cost_arr, 0)
        print(S.tsp())
        # 开始回溯
        M = S.array
        lists = list(range(len(S.X)))
        start = S.start_node
        count = 0
        self.progressBarProcess.setValue(2)
        while len(lists) > 0:
            lists.pop(lists.index(start))
            m = S.transfer(lists)
            next_node = S.array[start][m]
            print(start, "--->", next_node)

            # 标记点
            marker = QgsVertexMarker(iface.mapCanvas())
            marker.setCenter(QgsPointXY(self.point[start][0], self.point[start][1]))
            marker.setColor(QColor(0, 255, 0))
            marker.setIconSize(4 + count)
            marker.setIconType(QgsVertexMarker.ICON_CROSS)  # or ICON_BOX, ICON_X
            marker.setPenWidth(2 + count)

            del marker

            # 可视化路径
            director = QgsVectorLayerDirector(self.vectorLayer, -1, '', '', '', QgsVectorLayerDirector.DirectionBoth)
            strategy = QgsNetworkDistanceStrategy()
            director.addStrategy(strategy)

            builder = QgsGraphBuilder(self.vectorLayer.sourceCrs())

            startPoint = QgsPointXY(self.point[start][0], self.point[start][1])
            endPoint = QgsPointXY(self.point[next_node][0], self.point[next_node][1])
            # print(startPoint)
            # print(endPoint)

            tiedPoints = director.makeGraph(builder, [startPoint, endPoint])
            tStart, tStop = tiedPoints

            graph = builder.graph()
            idxStart = graph.findVertex(tStart)
            idxEnd = graph.findVertex(tStop)

            (tree, costs) = QgsGraphAnalyzer.dijkstra(graph, idxStart, 0)

            if tree[idxEnd] == -1:
                raise Exception('No route!')
            # Add last point
            route = [graph.vertex(idxEnd).point()]
            # Iterate the graph
            while idxEnd != idxStart:
                idxEnd = graph.edge(tree[idxEnd]).fromVertex()
                route.insert(0, graph.vertex(idxEnd).point())
            # Display
            rb = QgsRubberBand(iface.mapCanvas())
            # rb.setColor(Qt.blue)
            rb.setColor(QColor(0, 255 - 40 * count, 0))
            count = count + 1
            # This may require coordinate transformation if project's CRS
            # is different than layer's CRS
            for p in route:
                rb.addPoint(p)

            del tiedPoints, director, builder, graph, tree, costs

            start = next_node

        self.progressBarProcess.setValue(3)
        QMessageBox(QMessageBox.Information, "Information", "程序运行结束").exec()
        self.progressBarProcess.reset()
        self.textBrowserRecord.append("<font color=\"#FF0000\">" + QDateTime.currentDateTime().toString("[yyyy-MM-dd hh:mm:ss dddd]") + "执行完毕</font>")


    def saveRecord(self):
        """保存记录信息"""
        recordContent = self.textBrowserRecord.toPlainText()
        filename, _ = QFileDialog.getSaveFileName(self, "保存记录文件", "", "record files(*.txt)")
        if filename.strip() == "" or filename.split(".")[-1] != "txt":
            QMessageBox(QMessageBox.Warning, "Warning", "记录文件的路径错误！").exec()
            return
        with open(filename, 'w', encoding='utf-8') as fp:
            fp.write(recordContent)
            QMessageBox(QMessageBox.Information, "Information", "成功保存到记录文件！").exec()

    def clearRecord(self):
        """把记录的内容清空"""
        self.textBrowserRecord.clear()
        QMessageBox(QMessageBox.Information, "Information", "成功清除操作记录！").exec()
